<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="author" content="Moazzam Ahmed">
	<title>Function Calls from EVM based smart contract</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.7.5/web3.min.js"
		integrity="sha512-/T7YwzOsNeoNkuTfYKXn3CrJCGc5cnC8T4QW46Hy+3Xjdjrxzokmbx8M8Xavjq1K7dN4958kIRGy4J03VRIlSg=="
		crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body>
	<div>
		<h1>Function Calls from EVM based smart contract</h1>
		<h4 id="metamask_msg">Required metamask for transactions</h4>
		<button id="connectwallet" style="margin-bottom: 20px;">Connect Metamask</button>
		<fieldset>
			<legend>Web3 & Contract Details</legend>
			<form id="web3details" method="post">
				<label for="web3rpc">Network RPC</label>
				<input type="text" name="web3rpc" id="web3rpc">
				<label for="contractaddress">Contract Address</label>
				<input type="text" name="contractaddress" id="contractaddress">
				<br>
				<br>
				<label for="contractaddress">Contract ABI</label>
				<textarea name="abi" id="abi" rows="20" cols="50"></textarea>
				<br>
				<br>
				<button type="submit">Update</button>
			</form>
		</fieldset>
		<br>
		<fieldset id="container">
			<legend>Functions Calls</legend>
			<p>Type</p>
			<ul>
				<li>nonpayable -> Send Function without passing native token or msg.value</li>
				<li>payable -> Send Function with native token or msg.value</li>
				<li>view -> Call Function</li>
			</ul>
		</fieldset>
	</div>


	<script>
		let contract;
		let address;
		let web3;

		const connectwalletBtn = document.getElementById("connectwallet");
		const metamask_msg = document.getElementById("metamask_msg");

		const connect = async () => {
			if (window.ethereum) {
				web3 = new Web3(window.ethereum);
				try {
					// Request account access if needed
					const accounts = await window.ethereum.request({
						"method": "eth_requestAccounts",
						"params": []
					});
					address = accounts[0];
					console.log(address)

					window.ethereum.on("accountsChanged", async (accounts) => {
						address = accounts[0];
						console.log(address)
						metamask_msg.innerHTML = address ? `Metamask Connected (${address})` : "Required metamask for transactions. Metamask Not Connected";
						connectwalletBtn.style.display = address ? "none" : "block";
					});

					metamask_msg.innerHTML = `Required metamask for transactions. Metamask Connected (${address})`;
					connectwalletBtn.style.display = "none";
				} catch (error) {
					metamask_msg.innerHTML = "Required metamask for transactions. Metamask Not Connected";
					connectwalletBtn.style.display = "block";
					console.log(error)
				}
			} else {
				console.log(
					'Non-Ethereum browser detected. You should consider trying MetaMask!'
				);
			}
		}

		window.addEventListener('load', async () => {

			const abi = JSON.parse(window.localStorage.getItem('abi'));
			const contractaddress = window.localStorage.getItem('contractaddress');
			const rpc = window.localStorage.getItem('rpc');
			if (rpc) {
				web3 = new Web3(rpc);
			}

			document.getElementById("web3rpc").value = rpc;
			document.getElementById("contractaddress").value = contractaddress;
			document.getElementById("abi").value = JSON.stringify(abi, null, 2);

			await connect();

			if (!abi || !contractaddress || !web3) {
				return;
			}

			contract = new web3.eth.Contract(abi, contractaddress);

			const groups = abi.filter(element => element.type === 'function')
				.map(element => {
					const button = document.createElement('button');
					button.textContent = `(${element.stateMutability}) ${element.name}`;
					button.onclick = (e) => handleClick(e, element.stateMutability === 'view', element.stateMutability === 'payable');

					const group = document.createElement('div');
					group.setAttribute("class", "group");

					const brEle = document.createElement('br');
					const brEle2 = document.createElement('br');
					group.appendChild(brEle);
					group.appendChild(button);

					for (let i = 0; i < element.inputs.length; i++) {
						const input = element.inputs[i];
						const inputText = document.createElement('input');
						inputText.setAttribute("type", "text");
						inputText.setAttribute("placeholder", `${input.type} ${input.name}`);
						group.appendChild(inputText);
					}

					if (element.stateMutability === 'payable') {
						const inputText = document.createElement('input');
						inputText.setAttribute("type", "text");
						inputText.setAttribute("placeholder", `msg.value`);
						group.appendChild(inputText);
					}

					const display = document.createElement('span');

					group.appendChild(brEle2);
					group.appendChild(display);
					return group;

				});

			const container = document.getElementById("container");

			for (let i = 0; i < groups.length; i++) {
				container.appendChild(groups[i]);
			}
		});

		const METAMASK_POSSIBLE_ERRORS = {
			'-32700': {
				standard: 'JSON RPC 2.0',
				message: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',
			},
			'-32600': {
				standard: 'JSON RPC 2.0',
				message: 'The JSON sent is not a valid Request object.',
			},
			'-32601': {
				standard: 'JSON RPC 2.0',
				message: 'The method does not exist / is not available.',
			},
			'-32602': {
				standard: 'JSON RPC 2.0',
				message: 'Invalid method parameter(s).',
			},
			'-32603': {
				standard: 'JSON RPC 2.0',
				message: 'Internal JSON-RPC error.',
			},
			'-32000': {
				standard: 'EIP-1474',
				message: 'Invalid input or Insufficient Funds.',
			},
			'-32001': {
				standard: 'EIP-1474',
				message: 'Resource not found.',
			},
			'-32002': {
				standard: 'EIP-1474',
				message: 'Resource unavailable.',
			},
			'-32003': {
				standard: 'EIP-1474',
				message: 'Transaction rejected.',
			},
			'-32004': {
				standard: 'EIP-1474',
				message: 'Method not supported.',
			},
			'-32005': {
				standard: 'EIP-1474',
				message: 'Request limit exceeded.',
			},
			'4001': {
				standard: 'EIP-1193',
				message: 'User rejected the request.',
			},
			'4100': {
				standard: 'EIP-1193',
				message: 'The requested account and/or method has not been authorized by the user.',
			},
			'4200': {
				standard: 'EIP-1193',
				message: 'The requested method is not supported by this Ethereum provider.',
			},
			'4900': {
				standard: 'EIP-1193',
				message: 'The provider is disconnected from all chains.',
			},
			'4901': {
				standard: 'EIP-1193',
				message: 'The provider is disconnected from the specified chain.',
			},
			'4902': {
				standard: 'EIP-1193',
				message: 'Unrecognized Chain ID / Chain not found.',
			},
		}

		const getErrFromWeb3 = async (err) => {
			const defaultErrMsg = "Something went wrong. Please try again later.";
			if (err && err?.code) {
				if (METAMASK_POSSIBLE_ERRORS[err.code]) {
					return METAMASK_POSSIBLE_ERRORS[err.code].message;
				} else if (err.code === "ACTION_REJECTED") {
					return "User rejected signing";
				} else {
					return err.message;
				}
			}
			let chkErr = err?.toString();
			if (
				chkErr &&
				chkErr?.startsWith("Error: Transaction has been reverted by the EVM:")
			) {
				const errorObjectStr = err.message.slice(42);
				const errorObject = JSON.parse(errorObjectStr);
				let txHash = errorObject.transactionHash;
				try {
					const tx = await web3.eth.getTransaction(txHash);
					var result = await web3.eth.call(tx);
					result = result.startsWith("0x") ? result : `0x${result}`;
					if (result && result.substring(138)) {
						const reason = web3.utils.toAscii(result.substring(138));
						console.log("Revert reason:", reason);
						return reason;
					} else {
						console.log("Cannot get reason");
					}
				} catch (e) {
					var errMsg2 = e.toString();
					if (errMsg2) {
						if (errMsg2.startsWith("Error")) {
							var errObj2 = errMsg2.slice(errMsg2.indexOf("{"), errMsg2.length);
							if (errObj2.indexOf("{") !== -1 && errObj2.lastIndexOf("}")) {
								errObj2 = JSON.parse(errObj2);
								return errObj2.message;
							}
						}
						console.log(errMsg2);
					}
					console.log(err);
					return defaultErrMsg;
				}
			} else {
				console.log(err);
				return defaultErrMsg;
			}
		};

		const getErrorMessage = async (err) => {
			const defaultErrMsg = "Something went wrong. Please try again later.";
			if (err?.message && err.message?.includes("Internal JSON-RPC error.")) {
				let errMsg = err.message;
				if (typeof err.message !== "string") {
					errMsg = err.message.toString();
				}
				var errObj = errMsg.slice(errMsg.indexOf("{"), errMsg.length);
				if (errObj.indexOf("{") !== -1 && errObj.lastIndexOf("}")) {
					errObj = JSON.parse(errObj);
					const _errFromWeb3 = await getErrFromWeb3(errObj);
					return _errFromWeb3;
				}
			} else if (
				err?.message &&
				err.message?.includes("execution reverted:") &&
				err.message?.indexOf("{") !== -1
			) {
				let jsonObj = JSON.parse(
					err.message.slice(
						err.message.indexOf("{"),
						err.message.lastIndexOf("}") + 1
					)
				);
				if (jsonObj?.originalError) {
					return jsonObj.originalError.message;
				}
				return jsonObj;
			} else if (err?.message && err.message?.includes("execution reverted:")) {
				return err.message.slice(
					err.message.indexOf("execution reverted:"),
					err.message.length
				);
			}
			const errFromWeb3 = getErrFromWeb3(err, chainId);
			if (errFromWeb3) {
				return errFromWeb3;
			}
			return defaultErrMsg;
		};

		async function handleClick(event, isCallFnc, isPayable) {
			const button = event.target;
			console.log(button)

			const children = [...button.parentNode.children];
			const inputs = children.filter(element => element.nodeName === 'INPUT');

			const argsFilter = inputs.filter(input => input.placeholder !== "msg.value");
			const msgValue = inputs.filter(input => input.placeholder === "msg.value");

			const args = argsFilter.map(input => input.value);

			const buttonText = button.innerText;
			const functionName = buttonText.slice(buttonText.indexOf(")") + 1, buttonText.length).trim();
			console.log("functionName: ", functionName);

			const displaySpan = children[children.length - 1];
			displaySpan.innerText = "";
			
			let result;
			try {
				displaySpan.innerText = "Loading...";
				const contractMethod = contract.methods[functionName](...args);
				await contractMethod.estimateGas({ from: address });

				result = await contractMethod[isCallFnc ? "call" : "send"](isPayable ? { from: address, value: msgValue[0].value } : { from: address });
	
			} catch (error) {
				result = await getErrorMessage(error);
			}
			
			console.log("result: ", result)
			
			const res = JSON.stringify(result);
			displaySpan.innerText = res.replaceAll("{", "{\n\t").replaceAll(",", "\n\t").replaceAll("}", "\n}\n");
		}

		const web3form = document.getElementById("web3details");
		web3form.addEventListener("submit", async (event) => {
			event.preventDefault();
			const formData = new FormData(web3form);
			const rpc = formData.get("web3rpc");
			const contractaddress = formData.get("contractaddress");
			const abi = formData.get("abi");

			window.localStorage.setItem('rpc', rpc);
			window.localStorage.setItem('contractaddress', contractaddress);
			window.localStorage.setItem('abi', abi);

			window.location.reload();
		});

		connectwalletBtn.addEventListener("click", async (event) => {
			event.preventDefault();
			await connect();
		});

	</script>

</body>

</html>
